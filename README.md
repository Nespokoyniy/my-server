# my-server
**Глобальная цель**: Создать самодостаточную, безопасную и автоматизированную платформу для развертывания и управления веб-приложением, демонстрирующую полный цикл DevOps.

### Фаза 0: Фундамент (Подготовка и Конфигурация)

**Цель:** Заложить основу для безопасного и гибкого управления настройками на всех этапах.

**Задачи:**
1.  **Централизованное управление конфигурацией**
    *   Создать `.env` файлы для разработки (`backend/.env.dev`) и пример для продакшена (`.env.example`).
2.  **Логирование**
    *   Настроить модуль `logging` в `app/utils/logger.py`.
    *   Реализовать разные уровни логирования (INFO, ERROR, DEBUG).
    *   **Важно:** Настроить вывод логов в формате JSON для продакшена (для удобства парсинга инструментами вроде Loki).

---

### Фаза 1: Ядро Приложения (Разработка и Тестирование)

**Цель:** Реализовать полностью работое, протестированное и безопасное веб-приложение.

**Задачи:**
1.  **База данных и миграции**
    *   Поддерживать актуальность моделей и миграций Alembic.
2.  **Backend API**
    *   Завершить работу над основными эндпоинтами.
    *   Реализовать механизм **Refresh Tokens** для увеличения безопасности.
    *   Реализовать **эндпоинт `/health`** для проверки статуса приложения (БД, кеш). Критично для последующих фаз.
    *   Реализовать **административное API** (напр., `/admin/restart`, `/admin/logs`), защищенное дополнительной аутентификацией. Это безопасная альтернатива SSH для управления через Telegram-бота.
3.  **Frontend (SSR с HTMX)**
    *   Завершить базовую структуру.
    *   Довести до ума все HTML-шаблоны, обеспечить полную функциональность.
    *   Реализовать адаптивный и эстетичный UI на CSS.
4.  **Тестирование**
    *   Написать **интеграционные тесты**, проверяющие работу с БД и аутентификацию.
    *   Написать **тесты для фронтенда** (с использованием `pytest` и `httpx` для проверки рендеринга страниц и статус-кодов).

---

### Фаза 2: Упаковка (Контейнеризация и Оркестрация)

**Цель:** Упаковать приложение в Docker для переносимости и подготовить к работе в продакшене.

**Задачи:**
1.  **Оптимизация Dockerfile**
    *   Использовать многостадийную сборку (multi-stage build) для уменьшения итогового образа.
    *   Добавить `healthcheck` (в `Dockerfile` или `docker-compose.yml`), использующий эндпоинт `/health`.
2.  **Доработка docker-compose**
    *   Создать финальные версии `docker-compose.dev.yml` и `docker-compose.prod.yml`.
    *   Добавить политику перезапуска: `restart: unless-stopped`.
    *   Реализовать **скрипт инициализации** (`start.sh`), который запускает миграции (`alembic upgrade head`) перед запуском `uvicorn`.
3.  **Настройка Nginx**
    *   Создать конфиг `nginx/nginx.conf`.
    *   Настроить раздачу статики из `/frontend/static`.
    *   Настроить `proxy_pass` на бэкенд.
    *   Реализовать простую **балансировку нагрузки** между несколькими инстансами бэкенда (2-3 контейнера).

---

### Фаза 3: Развертывание и Автоматизация (CI/CD)

**Цель:** Обеспечить безопасный доступ к приложению из интернета и автоматизировать процесс деплоя.

**Задачи:**
1.  **Доступ из интернета**
    *   **Приоритет 1:** Настроить **WireGuard** на локальной машине и арендовать **VPS**. Настроить проброс портов с VPS на локальную машину через туннель.
    *   **Приоритет 2 (Fallback):** Использовать **Cloudflare Tunnel**. Создать бот-приложение в Cloudflare, скачать бинарник и настроить его в Docker-контейнере.
2.  **Настройка HTTPS**
    *   На VPS настроить Nginx + Certbot для получения сертификатов **Let's Encrypt**.
    *   *Либо* использовать встроенный SSL от Cloudflare Tunnel.
3.  **Настройка CI/CD (GitHub Actions)**
    *   Создать workflow-файл (`.github/workflows/deploy.yml`).
    *   **Этап `test`:** Запускать `pytest` внутри контейнера, используя `Dockerfile.tests`.
    *   **Этап `deploy`:** Через SSH подключиться к серверу (VPS), выполнить `git pull`, пересобрать контейнеры через `docker-compose -f docker-compose.prod.yml up -d --build`.

---

### Фаза 4: Мониторинг и Операции (Инструменты управления)

**Цель:** Реализовать системы для резервного копирования, безопасности и удобного управления.

**Задачи:**
1.  **Система бэкапов (`/backup`)**
    *   Создать скрипт `backup.sh` / `backup.py`.
    *   Логика: `pg_dump` -> архивация -> шифрование (`gpg`) -> загрузка в облако (Yandex Disk, S3) через `rclone` -> отправка отчета в Telegram.
    *   Настроить `cron` для ежедневного запуска.
2.  **Сканер уязвимостей (`/vuln-scanner`)**
    *   Создать скрипт `vuln_scan.py`.
    *   Логика: Запускать `trivy` для сканирования образов, `lynis` для аудита системы.
    *   Парсить вывод и отправлять отчет в Telegram.
    *   Настроить `cron` для еженедельного запуска.
3.  **Центр управления в Telegram (`/telegram-bot`)**
    *   **Важно: Не использовать прямой SSH (`paramiko`).**
    *   Бот должен общаться с системой **исключительно через защищенное API**.
    *   **Метрики:** Бот вызывает эндпоинт `/admin/metrics` (возвращает JSON с данными о CPU, RAM через `psutil`).
    *   **Управление:** Бот отправляет `POST /admin/restart?service=nginx` (эндпоинт, который внутри вызывает `subprocess.run(["docker", "compose", "restart", "nginx"])`).
    *   **Логи:** Бот отправляет `GET /admin/logs?service=backend&lines=50` (эндпоинт, который читает и возвращает последние N строк из log-файла).

---

### Фаза 5: Развитие (Дальнейшее масштабирование)

**Цель:** Масштабирование и углубление инфраструктуры.

**Задачи (по приоритету):**
1.  **Кеширование:** Добавить **Redis** в `docker-compose`. Использовать для хранения JWT blacklist, кеширования запросов к БД, хранения сессий.
2.  **Мониторинг (`/metrics`):** Настроить **Prometheus** (сбор метрик) и **Grafana** (дашборды для визуализации).
3.  **Оркестрация:** Мигрировать с Docker Compose на **Kubernetes** (k3s) с использованием **Helm**-чартов.
4.  **Infrastructure as Code:** Описать сервера и конфигурацию в **Terraform**.
5.  **Конфигурационный менеджмент:** Управление настройками серверов с помощью **Ansible**.
